import json
from pathlib import Path
import sys
import re
from typing import Optional, List, Dict # <--- Added this import

# --- Configuration ---
SCRIPT_DIR = Path(__file__).parent.resolve()
INPUT_CATALOG_JSON = SCRIPT_DIR / 'result.json'  # Generated by get_catalog.py
PARSED_MERMAID_DIR = SCRIPT_DIR / 'parsed_mermaid_code'  # Processed .mmd files
COMBINED_MERMAID_OUTPUT_FILE = SCRIPT_DIR / 'full_book_mindmap.mmd'
BOOK_ROOT_TITLE = "Full Book Mindmap" # You can change this

def load_json_file(file_path: Path) -> Optional[Dict]:
    """Loads a JSON file and returns its content."""
    if not file_path.exists():
        print(f"错误: JSON文件未找到 - {file_path}", file=sys.stderr)
        return None
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print(f"加载JSON文件 '{file_path}' 时出错: {e}", file=sys.stderr)
        return None

def read_mermaid_file_content(file_path: Path) -> List[str]:
    """
    Reads an .mmd file, skips the 'mindmap' and 'root(...)' lines,
    and returns the content lines.
    """
    content_lines = []
    if not file_path.exists():
        print(f"警告: Mermaid文件未找到 - {file_path}", file=sys.stderr)
        return [f"(Mermaid content for {file_path.stem} not found)"]
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        # Skip initial mindmap and root definition lines
        start_index = 0
        if lines:
            if lines[0].strip().lower() == "mindmap":
                start_index += 1
            if start_index < len(lines) and lines[start_index].strip().lower().startswith("root(("):
                start_index += 1
        
        for line in lines[start_index:]:
            content_lines.append(line.rstrip('\n')) # Keep original indentation, remove trailing newline
        
        if not content_lines: # If only root and mindmap were present
             return [f"(No content in {file_path.stem} after root)"]
        return content_lines
    except Exception as e:
        print(f"读取Mermaid文件 '{file_path}' 时出错: {e}", file=sys.stderr)
        return [f"(Error reading {file_path.stem})"]

def build_mermaid_for_node_recursive(node_data: Dict, current_indent_level: int, chapter_id_prefix: str, output_lines: List[str]):
    """
    Recursively builds Mermaid mindmap lines for a node and its children.
    """
    node_name = node_data.get("name", "未命名节点")
    node_type = node_data.get("type")
    current_index = str(node_data.get("index", ""))
    
    # Construct the full chapter ID (e.g., "1", "1.1", "1.1.1")
    current_chapter_id = f"{chapter_id_prefix}{'.' if chapter_id_prefix and current_index else ''}{current_index}"
    if not chapter_id_prefix and not current_index : # Handle top-level chapters that might just have index
        current_chapter_id = current_index if current_index else "node"


    indent = "\t" * current_indent_level
    output_lines.append(f"{indent}{node_name}")

    if node_type == "leaf":
        # Construct filename for the leaf's .mmd file (e.g., 1_1_1.mmd)
        mermaid_file_name = f"{current_chapter_id.replace('.', '_')}.mmd"
        mermaid_file_path = PARSED_MERMAID_DIR / mermaid_file_name
        
        leaf_content_lines = read_mermaid_file_content(mermaid_file_path)
        
        child_indent_str = "\t" * (current_indent_level + 1)
        for line in leaf_content_lines:
            # Add an additional indent level to the lines from the leaf's file
            output_lines.append(f"{child_indent_str}{line.lstrip()}") # lstrip to handle its own relative indents
                                                                    # if they were not perfectly zeroed.
                                                                    # A more robust way would be to find min indent
                                                                    # of the leaf content and subtract it.
                                                                    # For now, lstrip() is a simpler approach.
    elif node_type == "tree" and "children" in node_data and isinstance(node_data["children"], list):
        for child_node in node_data["children"]:
            build_mermaid_for_node_recursive(child_node, current_indent_level + 1, current_chapter_id, output_lines)

def main():
    print("开始合并Mermaid代码文件...")

    catalog_data = load_json_file(INPUT_CATALOG_JSON)
    if not catalog_data or "chapters" not in catalog_data:
        print(f"错误: 未能从 '{INPUT_CATALOG_JSON}' 加载有效的目录结构。", file=sys.stderr)
        return

    if not PARSED_MERMAID_DIR.is_dir():
        print(f"错误: 已解析的Mermaid目录 '{PARSED_MERMAID_DIR}' 未找到。", file=sys.stderr)
        return

    # Ensure the output directory for the combined file exists (though it's just a file)
    COMBINED_MERMAID_OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)

    full_mermaid_lines = ["mindmap"]
    # Add the main root for the entire book
    full_mermaid_lines.append(f"\troot(({BOOK_ROOT_TITLE}))")

    # Start processing top-level chapters
    # The first level of actual content nodes will be at indent level 2
    for chapter in catalog_data["chapters"]:
        build_mermaid_for_node_recursive(chapter, 2, "", full_mermaid_lines) # Start with indent level 2

    try:
        with open(COMBINED_MERMAID_OUTPUT_FILE, 'w', encoding='utf-8') as f:
            for line in full_mermaid_lines:
                f.write(line + "\n")
        print(f"已成功将合并后的Mermaid代码保存到: {COMBINED_MERMAID_OUTPUT_FILE}")
    except Exception as e:
        print(f"保存合并后的Mermaid文件时出错: {e}", file=sys.stderr)

    print("\n--- 合并完成 ---")

if __name__ == "__main__":
    main()
